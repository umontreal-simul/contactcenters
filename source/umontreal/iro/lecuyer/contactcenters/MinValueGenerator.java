package umontreal.iro.lecuyer.contactcenters;

import umontreal.iro.lecuyer.contactcenters.contact.Contact;

/**
 * Value generator for the minimum of values. This value generator defines an
 * internal array of value generators used by the {@link #nextDouble} method.
 * When {@link #nextDouble} is called, a value is generated using all registered
 * value generators and the minimum value, generated by $v[j^*]$, is returned.
 * It is also possible to get the index $j^*$ of the value generator having
 * returned the minimum as well as all the generated values. This class is used
 * by waiting queues and agent groups to generate the maximal queue times and
 * service times.
 */
public class MinValueGenerator implements ValueGenerator {
   private ValueGenerator[] vgens;
   private int maxVType;
   private boolean keepValues;

   private double[] values;
   private int lastVType;
   private double lastValue;

   /**
    * Constructs a minimum value generator with no registered internal value
    * generator.
    */
   public MinValueGenerator () {
      vgens = new ValueGenerator[0];
   }

   /**
    * Constructs a minimum value generator with an internal array of value
    * generators containing \texttt{initialLength} elements.
    * 
    * @param initialLength
    *           the number of elements in the internal array.
    */
   public MinValueGenerator (int initialLength) {
      vgens = new ValueGenerator[initialLength];
   }

   /**
    * Recreates the internal array of value generators for its length to
    * correspond to {@link #getMaxVType}.
    */
   public void compact () {
      if (maxVType == vgens.length)
         return;
      final ValueGenerator[] vg = new ValueGenerator[maxVType];
      if (vg.length > 0)
         System.arraycopy (vgens, 0, vg, 0, vg.length);
      vgens = vg;
   }

   /**
    * Returns the maximum index (non-inclusive) for which
    * {@link #getValueGenerator} returns a non-\texttt{null} value.
    * 
    * @return the highest index of registered value generators.
    */
   public int getMaxVType () {
      return maxVType;
   }

   /**
    * Returns the value generator corresponding to value type \texttt{vType}.
    * 
    * @param vType
    *           the queried value type.
    * @return the associated value generator.
    */
   public ValueGenerator getValueGenerator (int vType) {
      if (vType < 0 || vType >= vgens.length)
         return null;
      return vgens[vType];
   }

   /**
    * Sets the value generator corresponding to value type \texttt{vType} to
    * \texttt{vgen}.
    * 
    * Since the value generators are stored in an internal array, it is
    * recommended to use small value types. This will avoid the creation of
    * large arrays of \texttt{null}'s.
    * 
    * @param vType
    *           the affected value type.
    * @param vgen
    *           the new value generator.
    */
   public void setValueGenerator (int vType, ValueGenerator vgen) {
      if (vType < 0)
         throw new IllegalArgumentException (
               "Negative value type not supported");
      if (vgens.length <= vType) {
         if (vgen == null)
            return;
         final ValueGenerator[] v = new ValueGenerator[vType + 1];
         System.arraycopy (vgens, 0, v, 0, vgens.length);
         vgens = v;
      }
      vgens[vType] = vgen;
      if (vgen == null && vType == maxVType - 1) {
         int i;
         for (i = maxVType - 1; i >= 0 && vgens[i] == null; i--)
            ;
         maxVType = i + 1;
      }
      else if (vType >= maxVType)
         maxVType = vType + 1;
   }

   /**
    * Determines if the value generator is keeping all the generated values used
    * to compute the last minimum.
    * 
    * @return the generated values keeping indicator.
    */
   public boolean isKeepingValues () {
      return keepValues;
   }

   /**
    * Sets the keeping-values indicator to \texttt{k}.
    * 
    * @param k
    *           the new keeping-values indicator.
    */
   public void setKeepingValues (boolean k) {
      keepValues = k;
   }

   /**
    * Initializes all the associated value generators.
    */
   public void init () {
      for (int i = 0; i < maxVType; i++)
         if (vgens[i] != null)
            vgens[i].init ();
   }

   /**
    * Generates and returns a new value for the contact \texttt{contact}. For
    * each associated value generator, this method calls \texttt{nextDouble} and
    * returns the minimal value. If there is no associated value generator,
    * \texttt{Double.NaN} is returned.
    * 
    * @param contact
    *           the contact for which a value is generated.
    * @return the generated value.
    */
   public double nextDouble (Contact contact) {
      lastVType = -1;
      lastValue = Double.NaN;
      if (keepValues) {
         if (values == null || values.length != maxVType)
            values = new double[maxVType];
      }
      else
         values = null;

      double val = Double.POSITIVE_INFINITY;
      int vType = -1;
      for (int i = 0; i < maxVType; i++) {
         if (vgens[i] == null) {
            if (keepValues)
               values[i] = Double.NaN;
            continue;
         }
         final double cval = vgens[i].nextDouble (contact);
         if (keepValues)
            values[i] = cval;
         if (cval < val || !Double.isNaN (cval) && vType == -1) {
            val = cval;
            vType = i;
         }
      }
      if (vType == -1)
         return Double.NaN;
      lastVType = vType;
      return val;
   }

   /**
    * Returns the last value returned by {@link #nextDouble}.
    * 
    * @return the last generated value.
    */
   public double getLastValue () {
      return lastValue;
   }

   /**
    * Returns the value type for the last value. This corresponds to the index
    * of the value generator, as returned by {@link #getValueGenerator}, having
    * generated the chosen minimal value.
    * 
    * @return the index of the minimal value.
    */
   public int getLastVType () {
      return lastVType;
   }

   /**
    * Returns all the generated values upon the last call to {@link #nextDouble}
    * if {@link #isKeepingValues} returns \texttt{true}, or throws an
    * {@link IllegalStateException}. The length of the returned array
    * corresponds to {@link #getMaxVType}.
    * 
    * @return the generated values.
    * @exception IllegalStateException
    *               if the object does not keep generated values.
    */
   public double[] getLastValues () {
      if (!keepValues)
         throw new IllegalStateException ("Values not kept");
      return values.clone ();
   }

   /**
    * Returns the value generated by
    * {@link #getValueGenerator getValueGenerator} \texttt{(vType)} upon the
    * last call to {@link #nextDouble} if {@link #isKeepingValues} returns
    * \texttt{true}, or throws an {@link IllegalStateException}. If the
    * associated value generator is \texttt{null}, \texttt{Double.NaN} is
    * returned.
    * 
    * @param vType
    *           the queried value type.
    * @return the generated value.
    * @exception IllegalStateException
    *               if the object does not keep generated values.
    * @exception ArrayIndexOutOfBoundsException
    *               if \texttt{vType} is negative or greater than or equal to
    *               {@link #getMaxVType}.
    */
   public double getLastValue (int vType) {
      if (!keepValues)
         throw new IllegalStateException ("Values not kept");
      return values[vType];
   }
}
