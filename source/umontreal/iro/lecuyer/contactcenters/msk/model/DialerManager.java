package umontreal.iro.lecuyer.contactcenters.msk.model;

import java.util.ArrayList;
import java.util.List;
import java.util.ServiceLoader;

import umontreal.iro.lecuyer.contactcenters.PeriodChangeEvent;
import umontreal.iro.lecuyer.contactcenters.PeriodChangeListener;
import umontreal.iro.lecuyer.contactcenters.ValueGenerator;
import umontreal.iro.lecuyer.contactcenters.app.DialerPolicyType;
import umontreal.iro.lecuyer.contactcenters.contact.ContactFactory;
import umontreal.iro.lecuyer.contactcenters.dialer.AgentsMoveDialerPolicy;
import umontreal.iro.lecuyer.contactcenters.dialer.BadContactMismatchRatesDialerPolicy;
import umontreal.iro.lecuyer.contactcenters.dialer.Dialer;
import umontreal.iro.lecuyer.contactcenters.dialer.DialerList;
import umontreal.iro.lecuyer.contactcenters.dialer.DialerListNoQueueing;
import umontreal.iro.lecuyer.contactcenters.dialer.DialerPolicy;
import umontreal.iro.lecuyer.contactcenters.dialer.MismatchChecker;
import umontreal.iro.lecuyer.contactcenters.dialer.ThresholdDialerPolicy;
import umontreal.iro.lecuyer.contactcenters.msk.params.AgentGroupIndex;
import umontreal.iro.lecuyer.contactcenters.msk.params.DialerAgentGroupParams;
import umontreal.iro.lecuyer.contactcenters.msk.params.DialerParams;
import umontreal.iro.lecuyer.contactcenters.msk.params.ProducedCallTypeParams;
import umontreal.iro.lecuyer.contactcenters.msk.spi.DialerPolicyFactory;
import umontreal.iro.lecuyer.contactcenters.server.AgentGroup;
import umontreal.iro.lecuyer.contactcenters.server.AgentGroupSet;
import umontreal.ssj.rng.RandomStream;

/**
 * Manages a dialer performing outbound calls.
 * An object of this class encapsulates the parameters specific
 * to the dialer, and provides methods to construct the
 * corresponding {@link Dialer} instance, and to update its state
 * it during simulation.
 */
public class DialerManager extends CallSourceManager {
   private static final List<DialerPolicyFactory> dialerPolicyFactories = new ArrayList<DialerPolicyFactory> ();
   private static final ServiceLoader<DialerPolicyFactory> dialerPolicyFactoryLoader = ServiceLoader
         .load (DialerPolicyFactory.class);
   private CallCenter cc;
   private Dialer dialer;
   private AgentGroupSet targetSet;
   private int slIdx;
   private MismatchChecker mChecker;
   private final ParamUpdater upd = new ParamUpdater ();
   private CallNotifierForBadContactMismatchRate cn;
   private CallNotifierForAgentsMove cn2;

   private int[] minFreeAgentsTest;
   private int[] minFreeAgentsTarget;

   private int numCheckedPeriods;
   private double checkedPeriodDuration;
   private double slThreshInbound;
   private double slThreshOutbound;

   private RandomStream reachTestStream;
   private boolean useNumActionEvents;

   /**
    * Constructs a new dialer manager using the call center model \texttt{cc},
    * the dialer parameters \texttt{par}, and dialer index \texttt{k}. If
    * \texttt{k} is smaller than the number of outbound call types, this creates
    * a dialer producing calls of a single type. Otherwise, this creates a
    * dialer producing calls of randomly-chosen types.
    * 
    * @param cc
    *           the call center model.
    * @param par
    *           the dialer's parameters.
    * @param k
    *           the index of the dialer.
    * @throws DialerCreationException
    *            if a problem occurs during the creation of the dialer.
    */
   public DialerManager (CallCenter cc, DialerParams par, int k)
         throws DialerCreationException {
      super (cc, par);
      this.cc = cc;
      useNumActionEvents = par.isUseNumActionEvents ();
      slIdx = par.getServiceLevelIndex ();
      if (slIdx < 0 || slIdx >= cc.getNumMatricesOfAWT ())
         throw new DialerCreationException ("Invalid service level index "
               + slIdx);
      if (!par.getAgentGroupInfo ().isEmpty ()) {
         targetSet = new AgentGroupSet ();
         for (final DialerAgentGroupParams info : par.getAgentGroupInfo ()) {
            for (final AgentGroupIndex grp : info.getInboundGroup ())
               targetSet.add (cc.getAgentGroup (grp.getIndex ()));
            for (final AgentGroupIndex grp : info.getOutboundGroup ())
               targetSet.add (cc.getAgentGroup (grp.getIndex ()));
         }
      }
      final ContactFactory factory;
      final DialerList dialerList;
      if (k < cc.getNumOutContactTypes ()) {
         if (cc.getCallFactory (k + cc.getNumInContactTypes ())
               .isDisableCallSource ())
            throw new DialerCreationException ("Calls of type "
                  + (k + cc.getNumInContactTypes ())
                  + " cannot be generated by an arrival process");
         if (targetSet == null)
            targetSet = createTargetSet (k);
         factory = cc.getCallFactory (k + cc.getNumInContactTypes ());
         if (par.getDialerLimitLength () == 0)
            dialerList = new SingleTypeInfiniteDialerList (factory, k);
         else
            dialerList = new DialerListWithLimits (cc, k, par.getDialerLimit ());
      }
      else {
         try {
            CallFactory.checkOutbound (cc.getNumInContactTypes (), cc
                  .getNumContactTypes (), par.getProducedCallTypes ());
         }
         catch (final IllegalArgumentException iae) {
            throw new DialerCreationException (
                  "Cannot create multiple-call types dialer", iae);
         }
         for (final ProducedCallTypeParams pct : par.getProducedCallTypes ())
            if (cc.getCallFactory (pct.getType ()).isDisableCallSource ())
               throw new DialerCreationException ("Calls of type "
                     + pct.getType ()
                     + " cannot be generated by an arrival process");
         if (targetSet == null)
            targetSet = createTargetSet (par);
         final RandomStream stream = cc.getRandomStreams ().getDialerPStream (
               k - cc.getNumOutContactTypes ());
         try {
            factory = CallFactory
                  .createRandomTypeContactFactory (cc, par
                        .getProducedCallTypes (), stream, par
                        .isCheckAgentsForCall ());
         }
         catch (final CallFactoryCreationException cfe) {
            throw new DialerCreationException (
                  "Cannot create multiple-types dialer", cfe);
         }
         // if (par.getDialerLimitLength () == 0)
         // dialerList = new InfiniteDialerList (factory);
         // else {
         try {
            dialerList = new DialerListWithLimits (cc,
                  (RandomTypeCallFactory) factory, par.getDialerLimit ());
         }
         catch (final IllegalArgumentException iae) {
            throw new DialerCreationException (
                  "Cannot create dialer list with limits", iae);
         }
         // }
      }
      try {
         minFreeAgentsTest = CallCenterUtil.getIntArray (par
               .getMinFreeAgentsTest (), cc.getNumMainPeriods ());
      }
      catch (final IllegalArgumentException iae) {
         throw new DialerCreationException (
               "Error initializing minFreeAgentsTest", iae);
      }
      try {
         minFreeAgentsTarget = CallCenterUtil.getIntArray (par
               .getMinFreeAgentsTarget (), cc.getNumMainPeriods ());
      }
      catch (final IllegalArgumentException iae) {
         throw new DialerCreationException (
               "Error initializing minFreeAgentsTarget", iae);
      }
      reachTestStream = cc.getRandomStreams ().getDialerStream (k,
            DialerStreamType.REACHTEST);
      final DialerList usedDialerList = par.isDropMismatches () ? new DialerListNoQueueing (
            dialerList)
            : dialerList;

      final DialerPolicy dialerPolicy = createDialerPolicy (par, usedDialerList);

      final DialerObjects dialerObjects = cc.getDialerObjects ();
      final ValueGenerator pReachGen = dialerObjects.getProbReachGen ();
      final ValueGenerator reachGen = dialerObjects.getReachTimeGen ();
      final ValueGenerator failGen = dialerObjects.getFailTimeGen ();
      dialer = new Dialer (cc.simulator (), dialerPolicy, reachTestStream, pReachGen, reachGen,
            failGen);
      dialer.setUsingNumActionEvents (useNumActionEvents);
      dialer.addReachListener (cc.getRouter ());
      cc.getPeriodChangeEvent ().addPeriodChangeListener (upd);
      for (final AgentGroup grp : targetSet)
         cc.getRouter ().getDialers (grp.getId ()).add (dialer);

      if (par.isPreventMismatches ()) {
         mChecker = new MismatchChecker (dialer);
         for (final AgentGroup group : targetSet)
            group.addAgentGroupListener (mChecker);
      }

      if (dialerPolicy instanceof BadContactMismatchRatesDialerPolicy) {
         cn = new CallNotifierForBadContactMismatchRate (this);
         cc.getRouter ().addExitedContactListener (cn);
         dialer.addFailListener (cn);
      }
      if (dialerPolicy instanceof AgentsMoveDialerPolicy) {
         cn2 = new CallNotifierForAgentsMove (this);
         cc.getRouter ().addExitedContactListener (cn2);
      }
   }

   private AgentGroupSet createTargetSet (int k) {
      final AgentGroupSet targetSet1 = new AgentGroupSet ();
      final int I = cc.getNumAgentGroups ();
      final int KI = cc.getNumInContactTypes ();
      for (int i = 0; i < I; i++)
         if (cc.getRouter ().canServe (i, k + KI))
            targetSet1.add (cc.getAgentGroup (i));
      return targetSet1;
   }

   private AgentGroupSet createTargetSet (DialerParams par) {
      final AgentGroupSet targetSet1 = new AgentGroupSet ();
      final int I = cc.getNumAgentGroups ();
      for (final ProducedCallTypeParams ppar : par.getProducedCallTypes ()) {
         final int k = ppar.getType ();
         for (int i = 0; i < I; i++)
            if (cc.getRouter ().canServe (i, k)
                  && !targetSet1.contains (cc.getAgentGroup (i)))
               targetSet1.add (cc.getAgentGroup (i));
      }
      return targetSet1;
   }

   /**
    * Constructs and returns an object representing the managed
    * dialer's policy.
    * This method uses {@link DialerParams#getDialerPolicy()}
    * to get a type identifier for the dialer's policy.
    * It then retrieves parameters and initializes a dialer's policy
    * specific to the given type.
    * If the name of the dialer's policy corresponds to a constant in
    * {@link DialerPolicyType}, the method handles its construction
    * directly.
    * Otherwise, it queries every factory registered using
    * {@link #addDialerPolicyFactory(DialerPolicyFactory)} until it finds
    * one factory capable of constructing the policy.
    * If no such factory can create the policy, it uses the
    * {@link ServiceLoader} class to find a dialer's policy factory
    * dynamically.
    * If that last step fails, a dialer-creation exception is thrown.
    * @param par the parameters of the dialer's policy.
    * @param dialerList the dialer's list.
    * @return the constructed dialer's policy.
    * @exception DialerCreationException if an error occurs
    * during the creation of the dialer's policy.
    */
   protected DialerPolicy createDialerPolicy (DialerParams par,
         DialerList dialerList) throws DialerCreationException {
      DialerPolicyType dialerPolicy;
      try {
         dialerPolicy = DialerPolicyType.valueOf (par.getDialerPolicy ());
      }
      catch (IllegalArgumentException iae) {
         dialerPolicy = null;
      }
      if (dialerPolicy != null) {
         final AgentGroupSet testSet = cc.getDialerObjects ()
               .getAgentGroupTestSet ();
         switch (dialerPolicy) {
         case DIALFREE_BADCALLMISMATCHRATES:
            if (!par.isSetMaxBadCallRate ())
               throw new DialerCreationException
               ("No maxBadCallRate attribute set");
            if (!par.isSetMismatchRateThresh ())
               throw new DialerCreationException
               ("No mismatchRateThresh attribute set");
            if (!par.isSetNumCheckedPeriods ())
               throw new DialerCreationException
               ("No numCheckedPeriods attribute set");
            if (!par.isSetCheckedPeriodDuration ())
               throw new DialerCreationException
               ("No checkedPeriodDuration attribute set");
            return new BadContactMismatchRatesDialerPolicy (dialerList,
                  testSet, targetSet, 0, 1, par.getKappa (), par.getC (), par
                        .getMaxBadCallRate (), par.getMismatchRateThresh (),
                  par.getNumCheckedPeriods (), cc.getTime (par
                        .getCheckedPeriodDuration ()));
         case DIALXFREE:
            return new ThresholdDialerPolicy (dialerList, testSet, targetSet,
                  0, 1, par.getKappa (), par.getC ());
         case AGENTSMOVE:
            if (!par.isSetNumCheckedPeriods ())
               throw new DialerCreationException
               ("No numCheckedPeriods attribute set");
            if (!par.isSetCheckedPeriodDuration ())
               throw new DialerCreationException
               ("No checkedPeriodDuration attribute set");
            if (!par.isSetSlInboundThresh ())
               throw new DialerCreationException
               ("No slInboundThresh attribute set");
            if (!par.isSetSlOutboundThresh ())
               throw new DialerCreationException
               ("No slOutboundThresh attribute set");
            final AgentsMoveDialerPolicy.AgentGroupInfo[] groupInfo = new AgentsMoveDialerPolicy.AgentGroupInfo[par
                  .getAgentGroupInfo ().size ()];
            for (int j = 0; j < groupInfo.length; j++) {
               final DialerAgentGroupParams gpar = par.getAgentGroupInfo ()
                     .get (j);
               // final int iIn = gpar.getInboundGroup ();
               // final int iOut = gpar.getOutboundGroup ();
               final AgentGroup[] inboundGroups = new AgentGroup[gpar
                     .getInboundGroup ().size ()];
               final AgentGroup[] outboundGroups = new AgentGroup[gpar
                     .getOutboundGroup ().size ()];
               final double[] inboundProbs = new double[inboundGroups.length];
               final double[] outboundProbs = new double[outboundGroups.length];
               int idx = 0;
               for (final AgentGroupIndex grpIndex : gpar.getInboundGroup ()) {
                  inboundGroups[idx] = cc.getAgentGroup (grpIndex.getIndex ());
                  inboundProbs[idx] = grpIndex.getProbability ();
                  ++idx;
               }
               idx = 0;
               for (final AgentGroupIndex grpIndex : gpar.getOutboundGroup ()) {
                  outboundGroups[idx] = cc.getAgentGroup (grpIndex.getIndex ());
                  outboundProbs[idx] = grpIndex.getProbability ();
                  ++idx;
               }
               final AgentsMoveDialerPolicy.AgentGroupInfo info = new AgentsMoveDialerPolicy.AgentGroupInfo (
                     inboundGroups, inboundProbs, outboundGroups,
                     outboundProbs, reachTestStream);
               groupInfo[j] = info;
               info.setDelayInIn (cc.getTime (gpar.getDelayInIn ()));
               info.setDelayInOut (cc.getTime (gpar.getDelayInOut ()));
               info.setDelayOutIn (cc.getTime (gpar.getDelayOutIn ()));
               info.setDelayOutOut (cc.getTime (gpar.getDelayOutOut ()));
               info
                     .setMinimumIdleTime (cc.getTime (gpar
                           .getMinimumIdleTime ()));
               info.setMinimumIdleInboundAgents (gpar
                     .getMinimumIdleInboundAgents ());
               if (gpar.isSetMaximumIdleOutboundAgents ())
                  info.setMaximumIdleOutboundAgents (gpar
                        .getMaximumIdleOutboundAgents ());
               else
                  info.setMaximumIdleOutboundAgents (Integer.MAX_VALUE);
               if (gpar.isSetRequiredEmptyGroupsInOut ()) {
                  final int[] groupIndices = gpar
                        .getRequiredEmptyGroupsInOut ();
                  final AgentGroup[] groups = new AgentGroup[groupIndices.length];
                  for (int g = 0; g < groups.length; g++)
                     groups[g] = cc.getAgentGroup (groupIndices[g]);
                  info.setRequiredEmptyGroupsInOut (groups);
               }
               if (gpar.isSetRequiredEmptyGroupsOutIn ()) {
                  final int[] groupIndices = gpar
                        .getRequiredEmptyGroupsOutIn ();
                  final AgentGroup[] groups = new AgentGroup[groupIndices.length];
                  for (int g = 0; g < groups.length; g++)
                     groups[g] = cc.getAgentGroup (groupIndices[g]);
                  info.setRequiredEmptyGroupsOutIn (groups);
               }
            }
            numCheckedPeriods = par.getNumCheckedPeriods ();
            checkedPeriodDuration = cc
                  .getTime (par.getCheckedPeriodDuration ());
            slThreshInbound = par.getSlInboundThresh ();
            slThreshOutbound = par.getSlOutboundThresh ();
            final AgentsMoveDialerPolicy pol = new AgentsMoveDialerPolicy (
                  dialerList, groupInfo, par.getKappa (), par.getC ());
            if (par.isUseRoutingMatrix ())
               pol.setRouter (cc.getRouter ());
            return pol;
         default:
            throw new IllegalStateException ("Unsupported dialer policy "
                  + dialerPolicy.toString ());
         }
      }
      else {
         for (final DialerPolicyFactory dpf : dialerPolicyFactories) {
            final DialerPolicy pol = dpf.createDialerPolicy (cc, this, par);
            if (pol != null)
               return pol;
         }
         for (final DialerPolicyFactory dpf : dialerPolicyFactoryLoader) {
            final DialerPolicy pol = dpf.createDialerPolicy (cc, this, par);
            if (pol != null)
               return pol;
         }
         throw new IllegalStateException ("Unsupported dialer policy "
               + dialerPolicy.toString ());
      }
   }

   /**
    * Registers the dialer policy factory \texttt{dpf} for dialer managers. If
    * the user-specified dialer policy does not correspond to a predefined
    * policy, the registered factories are queried to find one capable of
    * creating a dialer's policy. This method must be called before the
    * call-center simulator is initialized.
    * 
    * @param dpf
    *           the new dialer policy factory to register.
    */
   public static void addDialerPolicyFactory (DialerPolicyFactory dpf) {
      if (dpf == null)
         throw new NullPointerException ();
      if (!dialerPolicyFactories.contains (dpf))
         dialerPolicyFactories.add (dpf);
   }

   /**
    * Returns the dialer managed by this object.
    * 
    * @return the managed dialer.
    */
   public Dialer getDialer () {
      return dialer;
   }

   public int[] getMinFreeAgentsTest () {
      return minFreeAgentsTest;
   }

   public int[] getMinFreeAgentsTarget () {
      return minFreeAgentsTarget;
   }

   public void init () {
      // if (getDialerPolicy() instanceof AgentsMoveDialerPolicy) {
      // final AgentsMoveDialerPolicy pol = (AgentsMoveDialerPolicy)
      // getDialerPolicy ();
      // int idx = 0;
      // for (AgentsMoveDialerPolicy.AgentGroupInfo grp : pol.getAgentGroupInfo
      // ()) {
      // System.out.println ("Number of moves in virtual group " + idx);
      // System.out.println (" In-to-out moves: " + grp.getNumInOutMoves ());
      // System.out.println (" Out-to-in moves: " + grp.getNumOutInMoves ());
      // ++idx;
      // }
      // System.out.println ();
      // }
      dialer.init ();
      if (cn2 != null)
         cn2.init();
   }
   
   

   /**
    * Returns a reference to the call center associated with this
    * dialer manager.
    * @return the associated call center.
    */
   public CallCenter getCallCenter () {
      return cc;
   }

   /**
    * Returns a reference to the target set of
    * agent groups associated with the managed dialer.
    * @return the target set of agent groups.
    */
   public AgentGroupSet getTargetSet () {
      return targetSet;
   }

   /**
    * Determines the 0-based index of the service-level
    * information matrix used if the dialing policy in
    * use takes service level (or acceptable waiting
    * time) into account for its decisions.
    * 
    * @return the index of the service-level information matrix.
    */
   public int getServiceLevelIndex () {
      return slIdx;
   }

   /**
    * Determines the number of testing periods used by
    * dialing policies taking cumulative statistics
    * (service level, mismatch rate, etc.) into account
    * for taking their decisions.
    */
   public int getNumCheckedPeriods () {
      return numCheckedPeriods;
   }

   /**
    * Determines the duration, in simulation
    * time units, of the testing periods used
    * by some dialing policies taking cumulative
    * statistics into account.
    */
   public double getCheckedPeriodDuration () {
      return checkedPeriodDuration;
   }

   /**
    * Determines the outbound-to-inbound threshold for
    * the service level. When the service level goes
    * below this threshold, some dialers start moving
    * agents from outbound groups to inbound groups.
    */
   public double getSlInboundThresh () {
      return slThreshInbound;
   }

   /**
    * Determines the inbound-to-outbound threshold for
    * the service level. When the service level goes
    * above this threshold, some dialers start moving
    * agents from inbound groups to outbound groups.
    */
   public double getSlOutboundThresh () {
      return slThreshOutbound;
   }

   /**
    * Determines if the dialer subtracts the number of
    * calls for which dialing is in progress from the
    * number of calls to dial. When dial delays are large
    * enough for the dialer to start often while phone
    * numbers are being composed, the agents of the call
    * center might receive too many calls to serve, which
    * results in a large number of mismatches. If this
    * attribute is set to
    * \texttt{true}
    * (the default), the dialer will take into account
    * the number of calls for which dialing is in
    * progress while determining the number of additional
    * calls to dial.
    */
   public boolean isUseNumActionEvents () {
      return useNumActionEvents;
   }

   private final class ParamUpdater implements PeriodChangeListener {
      public void changePeriod (PeriodChangeEvent pce) {
         final int mp = pce.getCurrentMainPeriod ();
         if (minFreeAgentsTest == null && minFreeAgentsTarget == null)
            return;
         int mft;
         if (minFreeAgentsTest == null || minFreeAgentsTest.length == 0)
            mft = 0;
         else if (minFreeAgentsTest.length > 1)
            mft = minFreeAgentsTest[mp];
         else
            mft = minFreeAgentsTest[0];
         int mfd;
         if (minFreeAgentsTarget == null || minFreeAgentsTarget.length == 0)
            mfd = 1;
         else if (minFreeAgentsTarget.length > 1)
            mfd = minFreeAgentsTarget[mp];
         else
            mfd = minFreeAgentsTarget[0];
         final DialerPolicy pol = dialer.getDialerPolicy ();
         if (pol instanceof ThresholdDialerPolicy) {
            ((ThresholdDialerPolicy) pol).setMinFreeAgentsTest (mft);
            ((ThresholdDialerPolicy) pol).setMinFreeAgentsTarget (mfd);
            if (mChecker != null)
               mChecker.checkThresh ();
         }
      }

      public void stop (PeriodChangeEvent pce) {}
   }
}
